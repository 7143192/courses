# `MicroService`

- 微服务的概念：即将一个系统的所有服务拆分成不同的小块，每一块之间单独的独立实现，并且相互之间互不干扰，（`self-contained modular`）实现解耦，并且**每一个小块的`service`可以实现不同系统的复用**。
- 但是单纯的拆分会带来问题：
  - 每个`service`相对独立，直观的体现就是可能部署在不同的端口上，而`client`可能不能直接的知道要调用的`service`的位置信息。
  - 在进行`Load-balance`的时候，不好进行负载的分配，因为目标未知。
- 解决上述遇到的**`service`位置不可知的问题**，需要额外的引入**`GateWay`和`Registry`**。`GateWay`的作用是与`client`端直接的交互，而将后端服务的详细情况向用户屏蔽，即用户只需要向`gateWay`传输一个`API`,由`GateWay`解析获取的请求路径并进行重定向。`Registry`作用是用于注册每一个`MicroService`,并以键值对(`serviceName:IP,PORT`)进行存储。而`GateWay`在进行重定向的时候，只需要向`Registry`处询问对应`Service`的信息就可以实现重定向。需要注意的是，`Registry`是唯一一个真正知道每个服务的位置信息的`server`,即即使有`service`发生了`crash`重启之后也需要重新的注册，而`GateWay`只能通过询问`registry`才能获取对应信息，即`GateWay`本身也是不知道`service`的具体位置的。
- 所以`MicroService`最终的结构应该是：
  - `GateWay`(与`client`交互的网关)，一般运行在8080端口
  - `Registry`,运行在一个其他的端口上
  - 一系列的`service`，都需要去`registry`的端口处进行注册。且这些`service`与`registry`以及`gateWay`都没有运行在相同的端口上。
- `Serverless`:
  - 并不是真正的"没有服务器"
  - 只是在后端运行轻量级的`service`环境
  - 将基础设施交给`cloud`来托管。但是`cloud`并不能真正的托管过于复杂的有状态服务，所以需要这个服务是**`stateless`**的。
  - 是一种**事件驱动的(`event-driven`)**的架构。
- 

