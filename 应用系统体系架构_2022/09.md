# `09-Caching`

- 对于数据库系统，最好将其部署在**内网**中，这样别人通过外网就不能访问了，一是安全，而是更不容易引起数据库之间的干涉。
- 对于`B/S/DB`架构，`S`层相对于数据库层而言，`CPU`利用率更高，而内存利用率相对更低。`DB`层就是反过来。
- `Spring JPA`已经实现了对于`RDB`(关系型数据库)的缓存，那我们仍然需要自己来实现一部分的`cache`，一个是自定义`cache`更方便进行存储与获取(系统提供的`buffer`不易受控制)，一个是并不是所有的数据库都是`relational`的，即对于非关系型数据库，并没有现成的`cache`实现。
- **`MemCached`**:
  - 本质上就是一个`in-memory K-V Store`.并且其`Value`类型比较单一，一般都是字符串。
  - `MemCached`是可以进行分布式的缓存存储的，只不过它的分布式部分(即多个不同的缓存节点)是运行在**`client`**端的。
  - 关于其具体使用，参见课件上面的例子。需要注意的是，除了可见提到的之间使用他提供的`annotation`之外，我们最好是**自定义`key`的名称**，这样更加有利于后续的存储与获取。(比如一个系统中有多个不同含义的`id`项，如果只是使用自带的`annotation`,则容易引起缓存混乱。)第二个需要注意的点是，`namespace`是用于区分不同的`memcache`区域的。即相当于对于存储在内存中的内容进行了**区域划分**。
  - `MemCached`是可以做分布式的。其一个特点是**会将不同节点上面的内存汇总在一起生成一个整体的`cache`区域**。这样的话可以提升整体的性能，使得不同节点之间的资源可以充分被使用。
  - `MemCache`的`Memory management`机制：根据长度进行区域的划分，并且当一个新的内容过来时，根据其长度选择合适的区域进行存储。这与`ICS中的malloc`时的长度划分类似。所选的长度都是应该满足一定的规则的。
  - 关于`MemCached`的分布式节点选择机制：参见`ppt`18页。具体来说，就是首先将所有的`node`进行`Hash`,(由于哈希机制不确定，所以哈希之后的顺序也是不确定的)，之后将新的数据进行哈希，哈希结果距离哪个节点最近就存入那个节点。如果添加新的节点，就对新节点进行哈希，并进行**相邻区域**的数据存储位置的重新分配。
- **`Redis:`**
  - `Redis`也是一个`KV Store`,但是其也常常被作为一个`NOSQL`来使用。其`value`类型相对丰富。
  - 使用`in-memory dataset`,并可以进行**主从备份(`Master-Slave replication`)**。(因为`Redis`可以起到数据库的作用，因而需要对于存储的数据进行备份处理。)
  - `Redis`的安装以及启动直接看官网：https://redis.io/docs/getting-started/installation/
  - `Redis`中存储的都是`Object`对象，获取之后记得要转化为想要使用的类型。
  - `Redis`甚至都可以做`Messaging`...。
- `cache`中最好存储的是**只读对象或者几乎不会被修改的对象数据信息**。(`recall:ICS-->Cache write through`)
- 