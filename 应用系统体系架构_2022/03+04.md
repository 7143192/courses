# `03-messaging-jms,04-Kafka`

- 对于那些在数据库中存在外键关联的实体类，如果对于其进行关联修改而这个修改又是发生在不同的事务中，(如`order`与`orderItem`位于不同的事务中)可能会由于外键无法正确关联而出错。而这种出错具体的表现应该是与具体实现有关的。如大二下的电子书店中，个人实现时将`order`与`orderItem`的写入数据库操作分在两个不同的函数，这时候如果出现上述无法关联的问题，作为主体的`order`应该是可以成功写入数据库的，但是`orderItem`会由于位于另外的事务中而无法正确的进行关联而报出死锁的错误而无法写入数据库。
- 要注意`spring`出对于`transaction`的声明只是对于返回到`spring`的数据而言的，而真正做了事务的传播属性和隔离属性的位置是数据库。所以，如果`spring`和数据库中声明不同时，尤其是**`spring`中的声明等级低于数据库中的声明时**，很可能会出现无法正确进行事务传播和隔离的问题。
- 同步通信机制：(`client-server`模式)
- 优点：实现简单，并且请求被接收并处理后`client`会立刻得到响应。
- 问题：
  - 紧耦合：一个函数直接做为接口暴露给多个系统使用，在这个接口被做了显式修改之后，涉及到的调用位置都要修改，使得程序较难维护。
  - 不能确保传输成功：若请求发送失败，不会缓存或重新尝试，而是直接抛出异常，正确性不能保证。
  - `software speciation`：接口维护困难。容错性差。
  - 没有`request buffer`:不会对暂时无法发送或发送失败的请求进行缓存。
  - 典型的请求响应结构，只有上一个请求结束/抛出异常下一个异常才会被处理。
  - `client`与`server`之间的通信是不可回放的，即出错之后不会自动尝试恢复。
- 异步通信机制：(中介者模式)
- 请求发出者：`producer`,请求最终接受者：`consumer`。
- 异步通信如何解决同步通信的一些问题：
  - 紧耦合-->松耦合。请求发出者与请求的处理者不在直接的做交互，而是通过中介的消息中间件做间接的交互，从而使得交互时不同模块的接口不会直接暴露，从而降低了耦合程度。
  - 不能确保传输成功-->可以保证成功性。若初始时请求失败(`server`未在线/超时/其他异常),消息中间件若设置为持久模式，则会持续的尝试直至第一次成功。(当然非持久模式就不是)
  - 解决了`software speciation`问题。接口之间耦合程度下降，使得维护更加容易。
  - 会使用`request buffer`来暂时(会设置过期时间)存储发送失败的请求。
  - `producer`发送的请求会先被消息中间件接收，之后再发送给`consumer`,这个过程不是即时同步的，中间可以有时间间隔，同时`producer`发送之后不需要等待响应而可以直接去做其他操作。`consumer`在处理之后也先会将响应发送给消息中间件，之后通过中间件在转发给`producer`。所以就消除了同步的请求响应结构，即发请求的不必等待响应，请求接收者也不必立刻串行处理请求。
  - 从上述分析还可以看见，对于消息中间件而言，`producer`与`consumer`都既可以发消息也可以接受消息，所以是等价的。就不再存在同步通信时的`client-server`通信模式了。即对于`topic`而言，所有的服务器都相当于`client`,所以`message`的发送和接收才会是**`peer-to-peer`**。
  - 异步通信相对于同步通信，其在`workload`起伏波动比较大时更加适用，因为异步通信的可回放机制使得请求发送的可靠性和成功性较高。
- 也有缺点：请求发出者无法及时接收响应，实现相对复杂，同时若处理请求过程中抛出异常，初始的`producer`很难接收到。
- **消息**的定义：是进行应用之间或系统构件之间通信的一种方式(`peer-to-peer`)。`JMS API`:`JAVA Message Service API`.
- 消息的特点：
  - 低耦合。
  - `peer-to-peer`,即所有的都相当于`client`,一个`client`可以想其他的`client`发送消息，也可以接收其他`client`发过来的消息。并且只与消息中间件进行直接的交互。
  - 支持异步通信：见上面异步通信部分。
  - `JMS API`，消息中间件(`MOM`)是支持事务操作的，所以他也是一个`Resource Manager`。
  - 可靠：`JMS`可以确保一个`message`会被正确的传递，并且成功之后不会再次发送。
- `Message`的组成部分：`header`（必须要有，其中包含一些消息属性），`properity`（`optional`,声明`message`的一些特殊属性），`body`（`optional`,`body`不是必须的是因为消息主要是起到一个成功接收或发送的声明作用即可，其具体内容并不很重要）。
- `header`包含一些`pre-defined fields`:(`S--send, C-- client, P--provider`)
  - `JMSDestination (S)`：确定`message`会被发送到哪一个`topic`中去。
  - `JMSDeliveryMode (S)`:分为**持久性和非持久性**两种。持久性指的是`message`会被保证一定会被成功接受一次，是用于**短信**等业务场景，非持久性指的是只会尝试一次，成功就是成功了，失败则直接放弃，适用于**股票交易**等很注重顺序的场景。
  - `JMSMessageID (S)`
  - `JMSTimestamp (S)`
  - `JMSCorrelationID (C)`：记录的是一些有关联性的`Message`的`ID`.(一个`message`可能被拆分为多个小的子`message`.)。
  - `JMSReplyTo (C)`
  - `JMSRedelivered (P)`用于记录已经被暂存的消息是否已经被重新转发(`boolean`)。
  - `JMSType (C)`：发送的消息的类型。如`JSON Object`等。
  - ` JMSExpiration (S)`：设置被缓存的`message`的过期时间，即过多长时间会被自动清空。
  - `JMSPriority (S)`
  - **用户不可以拓展`header`中的`fields`**.
- `properities`中包含的`pre-defined fields`:
  - `JMSXUserID (S)`
  - `JMSXAppID  (S)`
  - `JMSXDeliveryCount  (S)`
  - `JMSXGroupID  (C)`
  - `JMSXGroupSeq  (C)`
  - `JMSXProducerTXID (S)`
  - `JMSXConsumerTXID (S)`
  - `JMSXRcvTimestamp (S)`
  - `JMSXState  (P)`：过期/成功接收/`cached`。
  - **`property`中的`fields`是可以被拓展的，新的属性要符合一般编程语言命名规则，并且数据类型只能使用基本的类型。**这个拓展实际上就是为了方便后续的消息的部分选择。
- `body`中是`TextMessage`等内容。
- `CF`：`connection factory`,`D`:`Destination`，`Destination`一般是指的是消息中间件中的一个`queue/topic`。
- `Messaging Styles`:
  - `point-to-point`:**点对点**结构。此状态下使用的消息中间件为**`queue`**,即一个`message`只能有一个`consumer`
  - `publish/subscribe`结构：**发布/订阅**模式。此状态下使用的消息中间件为**`topic`**,即每一个`message`可以有多个`consumer`。
- 构建`JMS`的基本结构：(但是要注意使用不同的中间件可能最终实现不同，另外，使用`Spring`并不是说创建过程简化了，只是说一些默认操作`spring`托管操作了。)
  - 确定作为`Destination`的`DataBase`,并找到`JNDI`的树根(`InitialContext`)。
  - 找到作为消息中间件的`queue`/`topic`.
  - 创建`connection`和`session`。
  - 创建`producer`/`consumer`。
- 关于`JNDI`结构的补充：
  - `J:JAVA,N:Naming,D:Directory,I:Interface`
  - `Naming`存储的是一些`ID:NAME`的键值对，`ID`是消息中间件发送过来的对象的**编号**，是一组16进制，对用户不可读懂，`name`就是用户可以识别的对象名称，通过这个映射方便了用户查找对应的对象。
  - 注意，**`JNDI`中每个节点中存储的都是一个`Object`!**
- 关于`Message`不同设计模式的类型问题：
  - 同步通信：是**强类型**。指的是，要发送的消息类型必须与发送/接收消息的函数的参数类型一致，否则就会在**编译时**报错。
  - 异步通信：是**弱类型**。指的是，在使用异步通信时，信息都需要通过中间件进行转发，从而需要设计一种**发出者与接受者统一能够处理的消息数据传输格式**，如`JSON`,`XML`等。但是，由于这些类型在传输时本质上都是`string`,所以会出现**传入的`string`格式不符合具体要求时无法在编译过程中检查出来**，只有在执行过程中才会报错。
- `header`中的`JMS`属性没有人为设置时默认为空。
- `Kafka`:支持**分布式事件流**，其不区分`queue/topic`,统一称作`topic`,其操作信息会存储在`commit log`文件中。(`log-structured file`)。
- `Kafka`使用**`offset`**来记录每个消息入口在`Log`文件中的位置。由于**`topic`得消息可能会发送给多个不同的`consumer`**,所以不能在一个`consumer`读取之后就清除相关记录。`Kafka`会对监听这个`topic`的所有`consumer`进行分组，并记录每一组已经读取到的位置，当所有应该接受到这个消息的`consumer`所在的`group`都读取了这个消息之后，则**清除**这条消息。(为什么要在使用完成后清除？1.防止占用过多磁盘空间2.过多的`Log`会使得在进行遍历查找时性能变得很差。)
- `topic`的类型：
  - 同构:指的是每个`topic`种存储的都是同一种类型的`Message`(`recall:TextMessage,ByteMessage,etc.`)优点：每个对象大小相同，便于设置`offset`进行访问，缺点是可能需要更多的`topic`来存储不同的类型。
  - 异构：一个`topic`中可以存储多个不同类型的`Message`.优点是更加节省空间，缺点是对象大小不一，`offset`不均匀。
- `partition`:对于一个`topic`的划分，但是逻辑上还是属于同一个`topic`。更多的划分数量会使得`topic`的操作更好的并行，但是同时也带来了当出现某个`partition`崩溃时更加不好恢复和托管的问题。一个`topic`的划分数量是可以被指定的。
- `Kafka`中的`event`:一个`event`是一个绑定了**时间戳**的**键值对**。主要由`Header, Key, Value, TimeStamp`组成。其中`key`是可选的，但是在通过哈希函数映射到不同地`partition`时更多的使用`key`，是因为`key`是不会重复的，会减少重散列的可能，同时`key`一般比较短小，更好存储。`value`才是实际的`message`的具体内容。(被处理成`Byte Code`存储。)
- 在一个集群中，每一个`partition`被称作一个**`Broker`**。
- 为了提高分布式系统的**可靠性**，可以采用**牺牲空间换来可靠**的方式，即在不同分布式机器之间互相做**备份(`replication`)**处理。
- `customer Group`:用户组，由一系列相互关联的用户组成。这些用户之间的关系是随时可变的(因为有的用户可能会出现崩溃的问题)，他们之间的关系由`Group Coordirator`(组内协调器)来协调。
- 组内协调器主要是通过定时的**接收**组内用户发送的**心跳**来判断此用户是否正常。(`TIPS`:为什么不是主动发送来确认呢？主动发送是`req/res`结构(同步通信)，虽然可能更快地响应，但是实现复杂并且性能可能不是很好。)若一个用户出现崩溃的现象，则协调器会**重新平衡**组内用户的操作(即将挂掉的用户的工作分给其他正常的用户去做。)。
- `Kafaka`作为一种消息中间件，也是一种**资源管理器**，也是可以进行`transaction`的管理的。