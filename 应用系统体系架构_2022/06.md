# `06-Multithreading`

- 并行程序中两个重要的基本单元：`process,thread`.注意两者的区别：`process`都有自己各自的独立的内存空间，好处是不会出现进程之间的内存干扰，坏处是通信不方便，而`thread`一般都来源于同一个进程，拥有共享的`stack`等内存空间，但是`register,stack pointer`等还是独立私有的，有共同的内存空间就方便了进行线程间通信以及信息共享,但是更容易出现线程干扰问题.课件6主要是介绍基于`thread`的并发程序设计。

- `thread object`在`JAVA`中定义时主要有两种方式：**`implements runnable`与`extends Thread`**。但是更加推荐使用`implement`方式，因为**`JAVA`的机制是允许单继承但是允许多个接口实现**.

- 之后是几个基本的`JAVA`中关于线程操作的接口：

  - **线程创建**。`e.g.:(new Thread(new HelloRunnable())).start();`
  - **`sleep`**.注意`sleep`是使得调用此接口的线程**挂起对应的时间**，期间此线程不继续执行线程函数，要注意的是，传入的`sleep`的参数是一个**大致的**时间，即计算机的物理时钟是存在一定误差的。
  - `interupt`.与`ICS`中一致，`interupt`是将当前线程打断，并使其去执行其他的事情。在`JAVA`中，使用`interupted()`来判断一个线程当前是否处于被打断的状态，一般情况下若发现被打断应直接返回或者报出`InteruptedExcption`。
  - **`join`**:对于`joinable`的线程，使用此方法可以进行线程资源的回收,`i.e.:t.join()`。`thread`有两个回收状态，`detached,joinable`。只有`joinable`才可以使用`join`显式的进行回收，并且这是强制回收，即在此处等待其运行结束并立刻回收。所以可以通过`join`调用的位置来决定子线程结束的位置。`detached`则是在线程结束之后**自动**回收。若`join`有参数,则是在参数给定的时间内进行回收，若回收完成，则结束，否则子进程继续执行。这种方式可以用于**粗略的计算子进程的运行时间**。

- **`synchronization`**（一致性）：

  - 未同步的`thread`容易出现**线程干涉(可以理解为发生了线程的`interleave`)，内存不一致(即一个共享数据可能被几乎同时读取并被分别修改)**等问题。而引入`synchronization`则可能引入额外的线程竞争。

  - 实现`synchronization`的主要目的是实现并行线程对于共享变量读写的**`happens-before`**关系。

  - 实现同步的方式1为**引入`synchronized`**关键字。注意事项：对于多个声明为`synchronized`函数，其中的一个被调用，**其他的都不会被调用**，因为当前的synchronized方法会hold这个对象的的内部锁(`JAVA`中每一个`object`都有一个内部的`lock`)`synchronized`关键字可以解决线程干涉问题（因为强制保证了对于函数调用的顺序性），但是不好解决内存不一致的问题(因为仍然可能存在：1读，2读，1写，2写的问题)。并且由于这个关键字只是约束了函数的顺序性，所以在函数调用之间还可能出现别的线程引发的干扰问题。

  - 在`JAVA`中，`synchronized`关键字使用的每个对象的**内部锁**，并且每一个`JAVA Object`都有一个自己的内部锁。对于`static`方法，其适用的对应`JAVA Class`的内部锁。

  - 方式2为引入`synchronized staement`.即通过声明要同步的**具体的对象**来确定同步内容。这种方式可以在一定程度上降低同步锁的上锁粒度。

    ```java
    e.g.:synchronized(this) {
        lastName = name;
        nameCount++; 
      } 
      nameList.add(name); 
    ```

  - `thread`在`synchronized`情况下不能去获取已经被其他`thread`占据的`lock`，但是可以使用自己已经获取的`lock`来调用其他的需要**同一个**`lock`的方法。这种允许同一个`thread`重复多次获取同一个对象锁的方式被称为**可重入同步锁(`reentrant synchronized lock`)**.

  - `atmoic actions`(原子操作)不会发生`interleave`,因而不会出现线程干涉问题，但是仍然会出现内存不一致问题。因为它只保证了单个操作的原子性，而并没有规定对于共享变量的操作顺序，因而仍然存在同时被读取之后却分别修改的情况。使用**`volatile`**来声明原子操作变量。

- **`thread's liveness`**:

  - **`deadlock`**:死锁，即两个或者多个线程，都在等待对方的继续执行来执行放锁操作从而使得自己继续执行，从而导致了所有线程都无法正常执行下去而阻塞住。
  - **`stravation`**:指的是线程长时间无法竞争得到共享资源。
  - **`livelock`**:指的是`threads`之间忙于进行**相互的通信协调**而都无法去获取锁。需要注意，死锁是都拿了锁但是无法释放而阻塞，活锁是都没拿到锁，而在一直交流到底谁该拿锁而阻塞。

- **`Guarded Lock`**:

  - 主要作用是实现多个线程之间的**执行顺序的协调作用**。
  - 方式1：通过`while`一直死循环，直至需要的条件成立。但是这样显然会使得程序的性能极差，并且会占用过多的计算机资源。
  - 方式2：使用`wait()`,之后通过`notify(All)()`唤醒。注意事项：`wait`是会在被调用时是当前`thread`进入挂起的休眠状态的，并且会**释放**`thread`在此之前已经获取的`lock`.注意`wait`退出之后**仍需要进行条件检查，因为用于`notify`的信号并不一定是这个`thread`在`wait`的那个信号**，因而使用`while`。
  - 理解课件上的`producer-consumer`的例子！

- **`Immutable Object`(不可变对象)**：

  - 指的是创建之后对象**状态不会发生改变**的对象。
  - 要注意，不可变对象**不是不能修改，而是说修改需要在其一个复制上进行**，既要创建一个与原来相同的对象来修改，而不是在原始对象本身上进行修改。

- 创建一个不可变对象的方法：

  - ```
    Don't provide "setter" methods — methods that modify fields or objects referred to by fields.
    Make all fields final and private.
    Don't allow subclasses to override methods. The simplest way to do this is to declare the class as final. A more sophisticated approach is to make the constructor private and construct instances in factory methods.
    If the instance fields include references to mutable objects, don't allow those objects to be changed:
    Don't provide methods that modify the mutable objects.
    Don't share references to the mutable objects. 
    ```

- `Higher level Concurrency Objects`:(了解)

  - `Lock Objects`:其主要的实现逻辑实际上与之前提到的**对象内部锁**类似，但是区别是其可以进行尝试获取锁，并在失败之后退出。即`tryLock API`.

  - ```java
    e.g.:
     try {
              myLock = lock.tryLock(); 
              yourLock = bower.lock.tryLock(); 
          } finally {
              if (! (myLock && yourLock)) {
                  if (myLock) { lock.unlock(); } 
                  if (yourLock) { bower.lock.unlock(); }//若没有同时拿到两个lock，则确保当前thread不会占有任意一个lock
              } 
          }
    ```

  - `Executors`:主要有三类`Object Type:Executor,ExecutorService, ScheduledExecutorService`.

  - `Thread Pool`:线程池，即最大实例个数是有限的，越界时会使用`LRU`替换，同时线程池中`thread`是由系统进行管理的，而不是用户进行管理，这就使得用户调用线程时可能存在的不一致问题不存在了。

- 