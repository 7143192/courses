# 16-`MYSQL Opt 2`

- **`InnoDB Table`的优化**：
  - 使用`OPTIMIZE TABLE`关键字进行数据表的优化，主要是进行表对应`block`的重新`orgnaize`,以降低碎片化程度。
  - 不要创建一个很长的`Primary Key`.对于主键，主要由**`UUID`**与**自增主键**两种。而一般使用**自增主键**更好。首先，自增主键占用的空间更少，一般是一个`int`占用4`bytes`，而一个`UUID`占用的空间要远大于4`bytes`，其次，在`MYSQL`中，主键一般都会做了索引，并且索引一般会使用`B+`树进行存储，对于订单表这样可能会发生频繁的插入，读取，修改以及删除操作的表格，若使用`UUID`，以插入为例，可能就需要在索引中加入大量的中间数据，因而就会导致频繁的数据移动，甚至可能会导致分配新的页表，因而性能较差，而若使用自增主键，往往只需要在已有index尾部添加一个新的不会重复的数值，因而操作量更小，性能相对更好。并且在进行`join`操作的时候，使用自增主键会提升关联查询的性能。
  - `VARCHAR`更适用于一个长度是变化的字段。因为行格式会对`varchar`进行优化。并且在字段允许为空的情况下最好也使用`VARCHAR`.而`char`更加是用于**等长数据**的查询。
  - 对于数据有大量重复并且数据量本身很大的情况，最好使用`COMPRESSED`行格式。
  - 为了降低事务执行的压力，运行**`SET AUTOCOMMIT = 0`**,这样可以使得用户人为的开启和结束一个事务，有利于在一个事务中完成一系列操作，而如果不进行上述设置，那么数据库会默认为每一个`SQL`语句都开启一个事务，这样会加重系统的压力。
  - 但是对于**只读**的事务，却最好开启`AUTOCOMMIT = 1`,这样`MYSQL`可以对于只读操作进行优化。
  - 对于大量数据的写入操作的时候，最好将其分解成更细粒度的写操作，这样的话即使发生`rollback`性能也不会太差。但是如果不分解却发生了回滚，那么由于`MYSQL`的`log`机制，就会对性能产生很大的影响，这是因为回滚几乎需要与原始事务相同的时间才能完成回滚，会出现`Long Time Running Tx`,这会使得数据库的隔离级别降低，甚至失去并发能力，并且在这个过程中即使重启也不会终止回滚操作，因为会根据`LOG`继续回复。
  - 对于只读事务优化的具体操作：对于只包含`SELECT`关键字的查询，`MYSQL`在`AUTOCOMMIT`的前提下会使用`START TX READ ONLY`来开启只读事务，从而会在后续运行过程中**不对其他事务的读取操作上锁**，因而可以提升性能。所以在实际的`QUERY`场景中，可以尽可能的将`SELECT`放在一起来提升执行效率。
  - 在进行大块数据的导入操作的时候，向设置`set autocommit = 0`,在导入结束之后设置回1；对于大量的`UNIQUE Key`的导入可以先设置`set unique_check = 0`之后修改回1；对于大量`Foreign Key`的导入，可以先设置`set foreign_check = 0`结束之后在改回来。
  - 对于`InnoDB disk I/O`:调整`pool-size`,优化`flush`策略，设置`fsync`属性数值(频繁的小规模的`flush`性能应该好于一次性的大量`flush`，所以可以将`fsync`数值调小)。
  - 对于数据库表格操作的优化：使用`truncate Table`来清空一张表，而不是直接使用`DROP TABLE`.尽量不要在表建成之后轻易地修改主键，因为这会重构整张表。
  - 对于多张表进行优化：
- **`Memory Table`的优化**：
  - 一般只对于大量的只读数据建立对应的内存表。
  - 对于内存表中的索引，如果范围查找更多，最好建立`B-Tree`索引，如果单值查找更多，最好建立`Hash Index`。
- **`Buffering and Caching`**:
  - 关于`Pool Size`:可以指定每个**`chunk`**的大小以及实例的数量(数量在1到64之间)。并且一定要保证`pool-size` 是`chunk-size * instance_num`的整数倍，也就是说如果不是整数倍，会找一个大于设定的大小的最小的一个能够满足要求的大小。并且设置的`Pool Size`至少要1个`GB`.
  - 使用`LRU`策略，但是并不是直接插入末尾，而是放入中间位置，一般是距离尾部`3/8`的位置。
  - `Prefetching(read-ahead)`:在读取一个`Page`的时候，不光光取出这个`page`，而是一次读取多个相关联的`page`,为后续可能存在的数据读取做提前的优化。(通过`innodb_random_read_ahead`的属性来设置预先读取的数据量)。
  - `page flushing`:指的是将`dirty pages`写回磁盘。默认是到达一个**"下水位"**才会自动地进行`flush`,这个参数是可以调节的,默认是10%。
  - `saving and restoring pool states`:将缓存状态在关机之前写入文件，在启动之后读取文件直接恢复，这样减少了重新启动的时候的`warmup`阶段的时间。
- 