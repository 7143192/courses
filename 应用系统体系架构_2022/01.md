# `Architecture `+`scope`

- `Architecture `:
  - 大二下完成的系统虽然实现了基本功能，但是有安全缺陷，即，所有系统聚合在一起，一旦任意一部分被攻击(如数据库密码泄露等)会导致信息的安全性消失。所以可以尝试采用**将不同功能部分部署在不同服务器上面**的方式来解决。同时每一部分使用独立的**内网**`IP`，不会出现一部分崩溃其余部分均无法使用的情况。并且其他服务器无法直接的去访问不同机器上面的信息，因为他并不知道要访问的机器的`IP`.但是要注意一些关于同步的问题，如**时间一致，数据一致等**。
  - 关于**缓存**：一般可以直接使用本地的缓存，但是由于`cookie,session,localStorage`等均需要本地内存空间，可能会出现内存不足以用于缓存的情况(尤其是用户数据量很大时)。可以考虑采用**远程缓存**，即将缓存部署在远端服务器上面来实现。
  - `CDN`:`Content Delivery Network`.主要适用于传输图片，视频，音频等较大的数据内容。
  - 负载均衡：在大量请求到来时，根据当前不同服务器的运行情况(如一台服务器的`workload`以及剩余内存大小等)进行合理的分配，使得完成相同功能的不同机器的负载相对平衡。
  - 关于数据库：在数据量较大时，或者会发生大量读写时，单个数据库可能会产生过大的`workload`,而可能会崩溃。为了防止上述问题，可以采用**主从集群**的方式，使得写入操作只发生在主数据库中，而读操作会由主从数据库一起承担。要注意，虽然写只发生在主数据库中，但是也要做主从数据库的同步，不然在对从数据库进行读的时候会出问题。
  - **分布式**：简单的来说就是把一个大数据的处理分配给多个不同的进程来处理。要注意的是，分布式并不是说一定要运行在多台不同的机器上面，也可以运行在同一台机器上面，但是需要是由不同的进程，事务等来分别处理。
  - 反向代理：对于`client`端而言，反向代理器就相当于一个`server`.当`client`的请求发送过来时，反向代理服务器会将其请求分配给真正的服务器的某个节点去执行，并通过反向代理服务器将结果返回到`client`.而对于`client`而言，其并不知道是那个`server`的节点处理了他的请求，只知道是反向代理服务器处理了这个请求。所以可以通过这种方式来访问一些远端的服务器而不要主动的去连接端口，以此来减少负载。
  - 统一数据访问网关：主要起到屏蔽数据多样性的作用，从而使得上层传输数据更加便捷。因为不同类型的数据可能使用不同方式进行存储与传输(如`DB,CDN`等)，所以若有用户直接实现会比较复杂，并且耦合程度会比较高。通过统一数据网关，用户只需要向网关传递数据，而具体使用哪一类存储以及应该存储在那一台机器上面均有网关来协助处理，所以就能实现数据传输的解耦。
  - `NOSQL`:`Not All SQL`....
  - **微服务**：
- `scope`:(范围，**作用域**)
  - `HTTP`协议是**`stateless`**协议。`stateless`指的是`server`不需要存储用户访问时传递过来的`state`，而是通过返回到客户端的`cookie`中的`id`来确定客户端应该获取的对应的`session`。即，`stateless`状态下的`server`始终只有**一个**实例(单例模式),一个用户处理完就抛弃所有信息，并等待下一个用户。而`stateful`状态指的是每一个用户在发送请求时的信息都会被保存，即每个用户都对应着一个后台的实例化对象。(`Prototype`模式)**但是要注意的是，`stateful`状态下并不是说每一个新的session都会重新分配一个对象，而是在内存中可以存储的对象数量是有限制的，(即实例池大小是有限制的)原因一个是单个对象可能很大过多会浪费内存，一个是只允许几个固定的对象同时存在还可以在一定程度上防止`DDOS`(分布式拒绝服务攻击)**。内存中的对象在`stateful`状态下通过`LRU`类似的策略来保存多个对象信息，被替换的对象信息会以`JSON`的形式写入磁盘中。
  - `singleton`:单例模式对应的`scope`选项，设置方式为`@Scope("singleton")`，是`@Scope`的默认模式。即只在对象被创建时会生成一个实例化对象，之后都不会再创建新的了。
  - `prototype`:`stateful`状态下的`scope`选项。设置方式为`@Scope("prototype")`。即，每有一个请求就有一个实例化对象。`Spring`只支持创建此类型对象，而不管消除。
  - `applicationContext.getBean`:会动态的获取实例化对象，而不是直接使用依赖注入的方式来创建新的实例化对象。使用依赖注入方式，创建的实例化对象等于进行注入操作的类的实例化数量，而使用`applicationContext`获取到的实例化对象数量取决于要获取的类根据`scope`真正创建的数量。
  - `session`:根据发送请求的`session`数量来确定需要的`instance`个数。回忆上学期知识，同一个用户发送的请求位于同一个`session`中。
  - `request`:需要声明变量类型`WebApplicationContext`,每一个不同的`request`都会生成一个新的对象。且`request`是`prototype`的一个子类。
  - 理解老师课件上面的那个应该有几个实例化对象的例子。要注意**@Scope声明的位置**！
- 数据库的连接也是**池化**的。`Coonection Pool Size`:`2 * core_count + effective_spindle_count`。因为连接池主要看的是硬件的性能和配置而不是访问用户数量。但是当用户访问数量过大的时候，应该考虑增加**机器数量**。