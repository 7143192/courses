# `Lucene--Full-Text-Searching`

- `full-test-searching<-->Information retrival(IR)`

- 对于富文本搜索，这节课讲的一个很重要的概念就是**`Index`**。而对于`index`，其更加适用于`structed data`（如数据库中表等）。但是，在实际场景中我们仍然需要对于部分的`unstructed data`(**非结构化数据，即不具有一个固定格式的数据或数据库字段**，如`text, html`)进行`index`。

- `Index`的主要作用是加快数据的查找速度，并且`Index`最好加载**特异**的属性上面(如数据库中的主键列)，这样方便进行`Index`的比较，同时也加快了查找速度，使得`Index`性能更好。(如添加了`Index`的字段出现大量重复，反而会降低查找性能)

- **反向索引**：**正向索引**是说对于一个给定的文档，给出其中`token`的索引位置信息，反向索引说的是，对于给定的**`token`**,会先根据这个`token`所属的`field`类型，去文档索引表中去查找对应的`value`出现在所有文档中的频率，并通过这个频率去定位到这个`value`具体出现的文档`ID`,之后通过`ID`以及文档中的对应`token`的索引信息来获取这个`token`在这个·文档中的位置，最后就可以得到这个`token`。

- 进行反向索引的几个步骤：
  - `tokenize`（将文档中内容解析成单独的`token`）
  - `preprocessing`(将`token`分组，将其分配给不同的`field`)
  - `hash`（即上面提到的在表中根据映射找位置）
  
- `recall metrics`:查全率，`precision metrics`:准确率

- 四种主要的`Fields`:
  - `Keyword`:不会被分析(如`FileName`)，但是会被`indexed`并且会存储在`index`中。一般而言`keyword`是希望能够在读取对应的`index`数据时能够被一起获取出来的。
  - `Unindexed`:既不会被分析也不会被`Indexed`,但是数据会存储在`index`中
  - `Unstored`:会被分析也会被`indexed`，但是不会存储在`Index`中(因为一个是可能会很长，一个是可能会出现大量的**停用词**(即在大量文档中大量出现因而对于搜索不起确定作用的`token`))
  - `Text`:会被解析也会被`Indexed`。
  - 上述的“解析”就是指的是将文本拆分成多个`token`
  
- `Lucene`在删除`Index`文件之后，**`close`之前**是可以进行`undo`的，但是**只能`UndeleteAll()`**。

- `Lucene`没有提供对于`Index`的`update`操作，所以要想修改只能删除之后重新写。

- 调节`Lucene`的结果排名：
  - `Boost`
  
- `Lucene Scoring`:主要是基于**`TF-IDF`**。要注意的是`IDF`是一个惩罚系数，指的是一个`token`在多个文档中都多次出现，因而这个`token`是一个泛用词，所以这样的词在当前文档中即使出现很多次也应该对结果产生较小的影响。所以需要`IDF`项进行惩罚。

- 关于`solr`使用遇到的坑：`solr-9.0.0`需要至少`JDK11`才行，并且得运行`bin`目录下的`solr.cmd`才能运行，但是直接使用`bin`下面的`solr`不能运行，不知道为啥。命令为`bin/solr.cmd start -c/-e cloud`   其他配置看课件。

- 在将项目的`JDK`由8变为11之后，需要注意，`javafx`包不存在了，需要额外的引用如下`dependency`:

  ```xml
  <dependency>
          <groupId>org.openjfx</groupId>
          <artifactId>javafx-controls</artifactId>
          <version>11</version>
      </dependency>
      <dependency>
          <groupId>org.openjfx</groupId>
          <artifactId>javafx-fxml</artifactId>
          <version>11</version>
      </dependency>
  ```

  