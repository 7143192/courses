# 15-`MYSQL Optimization`

- `MYISAM`是`MYSQL`自己的一个系统，但是不支持事务。主要讲的是对于`InnoDB`的优化。

- `char,varchar,TEXT`用于存储文本的时候的区别：

  - `char`:存储的字符串长度固定，并且直接存储在表中。
  - `varchar`:存储的字符串可以是变长的，也是直接存储在表中。
  - `TEXT`:存储的字段不是直接存储在表中，而是只存储一个指针

- 对于表的优化1(数据库层面)：字段的选取是否合适，应该使得一个字段在正确情况下尽可能的占用更小的空间，更方便在一个`page`中一次性读取。道理与为何使用`B+ TREE`来进行存储相同。

- **`cluster index`（聚簇索引）**：**一个表中一般只有一个**。其保证了数据在磁盘上的存储的顺序与数据在表中的显示顺序相同，因而其很适合使用`B(+)`树进行范围查找，因而查找效率很高。一般而言，聚簇索引会自动的创建在`ID`列。而`ID`列又分为两种。一种是**自增主键**，即其实并没有实际意义的一列。一种是**唯一但是对于表中关系而言有含义的字段**，如身份证号等。其实对于第一种情况，使用**哈希索引**更好，因为一般对于自增主键的访问都是要访问某一个特定的行。但是对于自增主键使用聚簇索引也是合理的，因为在`join`的时候也会被用到。

- `row format`:(trade-off between the speed and the space.)

  - 紧凑模式：存储在磁盘上占用的空间大小取决于字段数据的实际大小。
  - 压缩模式：在紧凑模式下对于存储的内容进行进一步的压缩。
  - 冗余模式：即每个字段无论多长在存储的时候占用空间相同。对于声明的字段类型`col_name(N)`,其对于每一个数据分配的空间为`N `* 所使用的字符集中**最长的字节**数量。

- 数据库中**读取**操作很多，所以提升`SELECT `性能很重要。

  - 方式1：`index`。不使用索引需要全表扫描。而全表扫描需要读取文件的多个`block`,需要的`IO`多，所以慢。而`index`实际上就是一堆指针，所以文件小，所以快。性能越高的索引应该建在越容易被访问的列上面。索引可以创建在一个或多个列上面。`index`一般都与`WHERE`子句绑定。但是不合理的`index`会占据很多不必要的额外空间，从而使得性能很低。大多数索引都是创建在主键，`UNIQUE`等列上面。`MYSQL`中的`index`一般都存储在`B(+)`树中。一些特殊的索引，如空间索引会使用`R-Tree`等。
  - 关于多列索引的使用：一定是从左向右的，并且一定要从最左面的一个开始。否则这个`index`将无法被使用。比如，一个多列索引包含`ID,NAME, BUILDING`,使用`where`进行查找的时候，`ID/ID,NAME/ID,NAME,BUILDING`等都可以起作用，但是`NAME/NAME,BUILDING`等查找方式则索引不会起作用。
  - 对于数据量较小的表格，使用索引效果就不会很好。

- 对于**主键**的优化：

  - 主键可以为一列为多列。多列主键中，可能存在`NULL`字段。对于存在`NULL`的主键，在做索引的时候效果不好。而`NULL`一般都表示相同的值，因而更难区分。

- 对于**外键**的优化：

  - 将一些不太常用的字段分解到一个新的表中，之后通过外键关联到原来的表上去。通过这种方式来减少获取常用列的时候的`I/O`数量。
  - 

- 对于较少的索引数量，可以存储在`MEMORY`中。

- **多列索引**：至多**16**列。使用**前缀匹配**模式。

  - `e.g.`:

  - ```C++
    用到了index：
    SELECT * FROM test 
         WHERE last_name='Jones’; 
    SELECT * FROM test 
         WHERE last_name='Jones' AND first_name='John’; 
    SELECT * FROM test 
         WHERE last_name='Jones' AND (first_name='John' OR first_name='Jon’); 
    SELECT * FROM test 
         WHERE last_name='Jones' AND first_name >='M' AND first_name < 'N';
    没用到index：
    SELECT * FROM test 
        WHERE first_name='John’; 
    SELECT * FROM test 
        WHERE last_name='Jones' OR first_name='John';
    ```

  - 

- `B-TREE index`可以用于在进行**比较**（=，=>,<=,!=）操作的时候进行索引，也可以用于**不是以`%`开头**的`LIKE`子句查找时候进行索引。

- `Hash Index`只用于=/<=>(安全判等)的情况。但是性能很好，但是也有重散列问题。

- `NaN == NaN`=>`false`,与`NaN`进行比较结果都是`NaN`,但是安全判等计算不会返回一个`NULL`的值，既不会返回一个`NaN`.

- 对于数据大小的优化：尽可能地减少数据存储在`disk`上面的时候的占据的空间。如每一列的字段类型选择，每一行的存储格式，范式化，进行`join`操作的性能等。

- 对于数据类型的优化：对于既可以使用`string`也可以使用`int`的字段，**优先选择`int`而不要选择`string`**。但是`string`与`int`有着不同的类型比较原则，所以需要根据具体的需求来设计具体的字段类型。

- 关于类型`varchar,BLOB,TEXT`的比较：

  - 对于长度小于8`KB`的数据，推荐使用`varchar`.并且其内容会直接存储在对应的位置而不是存储指针。
  - 对于大于8`kb`的数据，推荐使用指针存储，即使用`TEXT/BLOB`。

- 表的存储有**行存**和**列存**以及**分开存**几种。比如，对于字段`A,B,C`:

  - 行存。特点：容易修改记录，读取同一个字段的数据的代价高，不同记录重复率低，空间压缩率低。

    | `A1` | `B1` | `C1` | `A2` | `B2` | `C2` |
    | ---- | ---- | ---- | ---- | ---- | ---- |

  - 列存。特点：不容易修改记录，读取同一个字段的数据的代价低，不同记录重复率高，空间压缩率高。

    | `A1` | `A2` | `B1` | `B2` | `C1` | `C2` |
    | ---- | ---- | ---- | ---- | ---- | ---- |

  - 分开存：

    | `A1` | `B1` | `A2` | `B2` | `C1` | `C2` |
    | ---- | ---- | ---- | ---- | ---- | ---- |

- 比如在双十一中，在下订单的时候需要**行存**，(`OLTP,online tx processing`)在分析销售额的时候，需要**列存**(`OLAP,online analysis processing`)。

- 对于**`BLOB`**类型的优化：

  - 为了减少对于`BLOB`类型的访问时候的开销，可以考虑将其**单独**存储成为一张表。
  - 对于单独存储了`BLOB`的表格，可以单独存储在一个额外的存储设备上面。
  - 对于`BLOB`字段的比较，其会为字段的每一个数值存储一个`hash value`,在比较的时候会先比较哈希值，若不相等，则说明一定不同，但是相等的哈希值也不一定能够说明具有相同的`BLOB`,需要额外的一次真正的字符串的比较。

- `MYSQL`如何关闭表：

  - `table_open_cache`中存储的是文件描述符(`file descriptor`)，而实际的文件内容会在打开之后存储在对应的`buffer`中。
  - 触发条件：`table_cache`满了(`LRU`)；需要进行`file-flushing`的时候。

- 在同一个数据库中创建很多的表格：

  - 进行基本操作性能差
  - 在进行数据读取(`select`)的时候，可能会涉及过多的表，在获取数据的时候会有很大的`overhead`。

- `MYSQL`中临时拓展的`cache`是不对用户开放的。

- `MYSQL`对于数据库的数量和数据表的数量都是**没有限制**的，但是计算机本身的容量会限制文件数量。

- `InnoDB/MYISAM`支持的一行最长大小为**65535(默认值)**。如果在`InnoDB`中人为设置过，那么一个表中一行最大长度不能超过设置的**一半**。所以一个表中各个字段预先分配的长度(`BLOB，TEXT`除外，因为是指针)和超过65535的时候，就会报错，同时，即使总长度没有超过65535，但是剩下的空间太少还是不行，因为对于每个字段，需要一些额外的空间(如1个`bit`)，用于作为标志位来表示字段属性(尤其是`NULL`字段)。