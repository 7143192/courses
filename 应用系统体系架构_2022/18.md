# 18-`partitioning`

- 表格分区的两张方式：**水平分区**和**垂直分区**(`MYSQL`不支持垂直分区, 但是`HDFS`会使用垂直分区)。

- 分区的好处：
  - 在使用`WHERE`子句进行查找的时候，可能只在某几个分区中进行查询，从而提高性能。
  - 可以提高单个`disk`的数据存储上限。
  - 。。。
  
- 几个主要类型：
  - `range partitioning`:根据某个字段的数值/字符串范围进行分区
  - `list partitioning`:
  - `HASH partitioning`:
  - `KEY partitioning`:
  
- `range partition`:

  - 使用`LESS THAN`字段，最后一个划分可以使用`MAXVALUE`,但是全部放在最后一个里面可能会使得分区很大，所以需要人为的后需添加一些新的分区。
  - 同一条记录不能位于两个不同的分区。
  - `RANGE()`函数的参数可以是一个函数，而不一定是一个原始的字段名。如`RANGE(YEAR(date))`等。
  - 对于为`NULL`的字段，默认直接插入**第一个分区**中。

- `List partition`:

  - 通过一个给定的不同**值域**进行分区，每个分区的值域不能重叠。并且不存在像`RANGE`中`MAXVALUE`的最终`catch-all`的特殊值。
  - 在插入一个没有分区匹配的数据的时候，会直接报错，需要额外的添加`IGNORE`关键字。
  - `NULL`字段在适用`LIST Partition`的时候如果没有声明会报错。需要额外声明一个新的（只）含有`NULL`的分区。

- `Column Partition`:

  - 用于对**非数值列字段**进行分区。但是对于`TEXT,BLOB`无效，因为这些在表中存储的是指针；也不支持`FLOAT, DOUBLE`,因为可能不精确。
  - `Range Columns Partition`:用法与`RANGE`基本相同，但是`RANGE COLUMNS`的参数必须要和真正的列名对应，所以不能是一个别的函数，但是可以是多个列。但是在多个列的时候，后一个分区的`LESS THAN `要大于当前分区的。`e.g.`:`(5,10)<(5,12);(3,5)<(4,6)`,但是要注意这个**比较规则和字符串的比较基本相同**，即`(10, 5) < (11, 10)`。

- `HASH partitioning`:

  - 参数可以是具体一列，也可以是对列数据处理之后的新的数据。

  - 在给定分区数量之后，默认为**取模**。

  - 一周改进的线性`HASH`算法.通过`LINEAR HASH`来调用。

    ```c++
    Find the next power of 2 greater than num. We call this value V; it can be calculated as:
    V = POWER(2, CEILING(LOG(2, num)))
    Set N = F(column_list) & (V - 1).
    While N >= num:
    Set V = V / 2
    Set N = N & (V - 1)
    ```

- `KEY Partitioning`:直接通过`KEY`进行分区。

- `subpartitioning`:

  - 即将每个分区再进行一次分区，即进行**组合分区**。如果需要对每个子分区进行额外的处理，那么可以对子分区进行命名。

- 一种数据库设计方案：将每一个字段约束为：`NOT NULL`。

- 在`HASH/KEY Partition`中，遇到`NULL`的时候直接作为**0**进行处理。

- 对于分区的修改：使用`ALTER TABLE`.但是这个指令会重构整张表的分区结构，性能可能比较差。

- 在`RANGE`中只使用`LESS THAN`而不使用两个端点的原因：在删除一个分区的时候，只会删除这个分区对应的数据，但是并不会影响后续的插入，因为只约束了范围的上限，所以是可以直接相连的。

  | `p1` | `p2` | `p3` |
  | ---- | ---- | ---- |

  删除`p2`之后：

  | `p1` | `p3` |
  | ---- | ---- |

- 在`range`和`list`中重新组织分区的方式：

  ```c++
  ALTER TABLE members REORGANIZE PARTITION n0 INTO (
  	PARTITION s0 VALUES LESS THAN (1960), 
  	PARTITION s1 VALUES LESS THAN (1970) 
  );//将一个旧的分区分解成两个新的分区
  
  ALTER TABLE members REORGANIZE PARTITION s0,s1 INTO ( 
  	PARTITION p0 VALUES LESS THAN (1970) 
  );//将两个旧的分区合并成一个新的分区
  
  ALTER TABLE members REORGANIZE PARTITION p0,p1,p2,p3 INTO ( 
  	PARTITION m0 VALUES LESS THAN (1980), 
  	PARTITION m1 VALUES LESS THAN (2000) 
  );//将多个旧的分区重新组织成多个新的分区
  
  ALTER TABLE tt ADD PARTITION (PARTITION np VALUES IN (4, 8)); 
  ALTER TABLE tt REORGANIZE PARTITION p1,np INTO ( 
  	PARTITION p1 VALUES IN (6, 18), 
  	PARTITION np VALUES in (4, 8, 12) 
  );//LIST PARTITION可以使用reorganize来修改每个分区中包含的value的值域。
  ```

- 在`HASH/KEY Partition`中是**不允许**直接删除一个分区。因为这两种`partition`的最终分区结果是与分区数量有关的，若删除一个分区，则会引起所有数据的重构。因而不能删除。

- 分区的交换：`ALTER TABLE pt EXCHANGE PARTITION p WITH TABLE nt`。条件：

  - 表`nt`不能在进行分区。
  - 表`nt`不应该引用其他外键。
  - 表`nt`和`pt`结构应该相同。
  - 表`nt`不应该是一个临时表。

- 
