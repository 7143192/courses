# 21-`TimeSeries Database`(时序数据库)

- 时序数据库：
  - 存储的数据都有**时间戳**。时序数据的特点是短时间内产生大量连续并且相差不大的数据，是对一些时间的持续追踪过程中产生的数据。生命周期有限，但是对于生成时间有精确度要求。
  - 对于时序数据，相比于关系型数据，其更加关心的是数据的生命周期以及对于某一个特定范围数据的查找，而很少进行某一个具体字段或者具体一条记录的查找。
  
- `InfluxDB`中数据存储：
  - 以`bucket`为单位进行存储，类似于关系型中的`Table`,**按列存储**。
  - 带下划线的是系统字段。
  - `_field`:是一个系统字段，由于时间戳不唯一，通过`_field`进行区分。不会进行索引。一个`field`包括`_field`列的一个域名和一个`_value`列的值。
  - `tag`:人为添加的，默认没有，可以进行索引(`time series index, TSI`)。也有`name,value`,但是`tag`的名字就应该是对应的那一列的名字，`value`就是某一行对应列的值。
  - `tag`与`_field`之间可以进行角色互换，需要根据实际情况来确定。
  - `series`:指的是一系列共享`_measurement,tag sets(即所有tag的名称),fields`的数据点。方便获取一系列同类数据点。
  - `InfluxDB`默认按照**时间升序**来存储多个数据点。
  - `InfluxDB`对于`write/update`类型操作有很高的限制，一般读取的数据不可以被修改/删除。但是删除还是可以进行的，即**可以删除那些已经写入磁盘的数据**，但是正在写入的数据**不能**被删除。
  - `InfluxDB`支持的是`Eventual Consistency`,即**优先保证读写操作的正确性以及优先级**。所以，当一个写操作影响到一个事务查询内容的时候，会等到数据查询结束之后之后才能执行这个写入数据的事务，所以当有一个很高的插入频率的时候，可能**不能立刻读取到最新的一些数据**。
  - 由于`InfluxDB`会根据`series`来判断数据类别，所以同一条记录连续发送多次的时候**只会存储一条**。
  - `InfluxDB`保证了查询的准确率优先级高于性能。
  - 也可以进行`shard`,类似于关系型数据库中的分区。但是要注意**同一个`series`应该分在同一个`shard`中而不应该被分割**。
  
  # 22-云数据库与数据湖部分

- `ORM`通过`JPA`生成`SQL`来访问数据库与自己写`SQL`的性能差别：`JPA`生成的`SQL`是经过大量数据积累生成的`SQL`,是经过大量优化的，所以性能虽然由于垮了`ORM`层，但是仍可能比自己写的`SQL`要好。

- 表行存更适用于点查询以及数据更新；表列存更适用于统计分析和批量加载。

- 从关系型数据库到湖仓一体：
  - 结构化数据存储：关系型数据库，`JDBC,SPRING....`
  - 非结构化数据存储：无固定格式的文本数据：`MongoDB`,时序数据：`TSDB`,表示层次关系的数据：图数据库。。。
  - 数据分布式存储：`Hadoop...`。分布式数据存储应该支持**宽表存储**，即一个字段应该足够宽来存储一条记录，甚至一条字段可能都需要分开存储。
  
- `HBase`:
  
  - 将所有字段构成不同的**列族**。同一个列族中的字段一起存储，不同列族中的字段可以不一起存储。
  - 每一行可能存储**多个时间戳**。
  - 支持分布式数据存储，即支持**宽表存储**。
  
- 数据仓库：**用于将多元数据源融合**。主要是通过**`ETL`**将异构数据转化为统一的结构。主要统一结构存储格式很多，以`RCFile,Parquet`为例。

  - `RCFile`:主要做法是将一张关系表分成不同的`block`。具体做法一种是仍然按照行存储，但是根据列分成不同的列族；一种是按列存储，将所有的行分成不同的行族。无论是行族还是列族，都可以作为一个`block`进行一个分布式的存储，这样实现了“同构性”。
  - `Parquet`:主要按照**列**存储。

- 但是通过数据仓库的`ETL`转化为中间格式的时候在进行查询的时候性能可能会很差，而如果把这个中间格式转化为一个标准的`SQL`格式，那可能会花费很长时间。所以提出了**数据湖**的概念。即先存储标准的原始格式数据，在需要的时候再将其导入数据仓库进行统一格式处理(**注：由于数据仓库主要是面向关系型数据，所以在进行按需转换的时候只会将关系型数据转化到仓库中，而非关系型数据的访问仍然是直接访问的**)。

- 数据仓库与数据库的对比：

  - 仓库主要面对关系型，湖面向所有数据。
  - 仓库需要有一个预先定义的`schema`,湖进行的惰性加载，即先存储原始格式数据，用的时候再转到`schema`,也即`schema-on-read`。
  - 仓库的访问速度比较快，湖存储性能较好，并将查询与存储解耦。
  - 仓库会根据`schema`筛选数据，所以数据质量更高，而湖不会进行预先检查，所以数据质量较差。

- **湖仓一体**：

  - 即不做数据仓库与数据湖的具体区分，而是在存储数据的时候直接存储在数据湖中，在进行数据获取的时候要**统一经过一个处理引擎**，来确定是要转化为关系形式的数据仓库的数据还是直接获得的非关系型数据。

- 一个应用系统的核心内容：**数据，通信**。