# `Web Services`

- `Web Service`的主要组成为`web`与`Service`两部分。

  - `Web`:主要是指的是进行网络通信所使用的**协议(`protocol`)**。例如`HTTP,FTP,SMTP(简单邮件传输协议)`等。这些协议大多基于**`TCP/IP`**协议，并且默认端口大多都是80.
  - `Service`:主要指的是处理传输数据的服务。其主要作用是使得**传输的内容与`C/S`端实现无关**(主要方式是实现`API`的文本化)，而一种很常用的能够满足与两端实现语言无关的一种传输格式就是**纯文本**。

- `SOAP(简单对象访问协议)`：

  - `SOAP`是基于`XML`的一种协议。即`SOAP`对于接口的文本化方式是通过`XML`格式文件声明的。

  - `SOAP`主要由`JAX-RPC`与`JAX-WS`两种实现方式。

    ```xml
    e.g.:
    //这个是用于发送请求时候的request.xml
    <?xml version='1.0' encoding='UTF-8' ?>
           <env:Envelope 
                     xmlns:env="http://schemas.xmlsoap.org/soap/envelope/"> 
               <env:Header /> 
               <env:Body>
                   <reservation xmlns="http://www.titan.com/Reservation">
                      <customer> 
                           <!-- customer info goes here --> 
                      </customer>
                  </reservation>
              </env:Body> 
          </env:Envelope>
    ```

  - `WSDL`:`Web Service Description Language`.(网络服务描述语言)这就是`SOAP`用于描述端口信息的主要的`XML`格式文件。`e.g.:`

    ```xml
    <?xml version="1.0"?>
        <definitions name="TravelAgent" 
              ......
              xmlns:titan="http://www.titan.com/TravelAgent"//描述端口路径信息
              targetNamespace="http://www.titan.com/TravelAgent"> //描述req目标信息     
        <!-- message elements describe the parameters and return values -->
        <message name="RequestMessage">
                <part name="cruiseId" type="xsd:int" /> //描述API的参数信息
                ......
        </message>
        <message name="ResponseMessage"> 
                <part name="reservationId" type="xsd:string" />
        </message>
    <portType name="TravelAgent"> 
       <operation name="makeReservation">//描述这个API的进行操作的名称
          <input message="titan:RequestMessage"/>
          <output message="titan:ResponseMessage"/>
       </operation> 
    </portType> 
    <binding name="TravelAgentBinding" type="titan:TravelAgent">
     <soap:binding style="rpc“ transport="http://schemas.xmlsoap.org/soap/http"/>
     <operation name="makeReservation"> 
         <soap:operation soapAction="" /> 
         <input> 
          <soap:body use="literal" namespace="http://www.titan.com/TravelAgent"/> 
         </input>//literal指的是in/out时使用文本格式传输
         <output> 
          <soap:body use="literal" namespace="http://www.titan.com/TravelAgent"/>
         </output>
     </operation> 
    </binding> 
    <!-- service element tells us the Internet address of a web service --> 
           <service name="TravelAgentService">//描述处理请求的service的名称
               <port name="TravelAgentPort" binding="titan:TravelAgentBinding"> 
                   <soap:address location="http://www.titan.com/webservices/TravelAgent" /> 
               </port> 
           </service> 
       </definitions> 
    ```

  - `SOAP`进行`WS`操作的流程：(以课件上面的`JAVA->C#`为例)假设`JAVA`端为`req`的发出方。则，在`JAVA`在发出请求时，`SOAP`会根据`WSDL`将进行请求的`API`转化为文本格式，即相当于在`API`发出后经过了一层`proxy`，其作用就是将`JAVA`版本的信息转化为`text`信息。之后，在`C#`端接收到这个`req`的时候，会进行相反的操作，即先将`text`格式数据根据`WSDL`转化为`C#`格式`API`参数，之后去调用`C#`端对应的接口即可。`C#`端发送`response`与上述流程几乎相同。

  - 关于`JAX-RPC`版本的`SOAP`看看课件上`country`的例子。

  - `JAX-WS`版本的实现相对简单，主要是通过`@WebService`声明类为一个`WS`类，使用`@WebParam`来表示要用于网络传输的参数。但是其本质还是`SOAP`,吉仍然需要`request.xml`来声明`request`信息，以及`WSDL`来定义具体的文本转化格式。`e.g.:Endpoint.publish(address, implementor);`

- `SOAP`的缺点：

  - 花费时间长，性能差。
  - 与数据具体传输格式紧耦合，并与两端使用的实现语言方式紧耦合。
  - 需要一个`WSDL`来额外地进行格式的统一，并且在传输之前需要一个`proxy`进行一次额外的转化。

- `Restful  Web Service`:

  - 是一种**以数据作为驱动的**网络服务协议。

  - 对于一个`REST Webservice`,其应该通过对于**同一个`API`**的不同的`Header`的声明来表示不同的操作

  - 核心是`REpresentational State Transfer`(表述性状态转移)。

    - `Representational`:对于这种协议而言，每一个数据都是一个**资源**，每一个资源都应该有一个可以唯一标识它的一个标识符，即**`URI`**.
    - `state`:`Restful WebService`只传输数据，而不关心数据的状态，所以`server`应该是`stateless`的，而数据状态都是由`client`端确定的，如`JS`脚本。
    - `transfer`:指的是`client`端的具体状态会根据数据的特点进行转换。

  - 是典型的`C/S`结构。

  - 由于`server`是`stateless`的，所以`REST`是可以做到**幂等**的，所以也方便了在不同的`client`端进行`cache`。

  - 对于`REST`请求的类型(`CRUD,create,read,update,delete`)，可以使用`HTTP`中的`HTTP Method`来对应。即：

    ```CPP
    GET-read
    POST-create
    PUT-update
    DELETE-delete
    ```

  - 通过返回的**状态码**来确定响应状态。即：

    ```
    200 OK
    201 Created
    202 Accepted
    303 See Other
    400 Bad Request
    404 Not Found
    409 Conflict
    412 Precondition Failed
    417 Expectation Failed
    500 Internal Server Error
    ```

  - `e.g.:`

  ```xml
  Request:
  POST /order HTTP1.1
  Host: starbucks.example.org
  Content-Type: application/xml
  Content-Length: . . .
  <order xmlns=“http://starbucks.example.org/”>//描述请求路径(order)
      <drink>latte</drink>//描述请求体(drink)
  </order>
  
  Response:
  201 Created//描述请求的响应情况
  Location: http://starbucks.example.org/order/1234//描述响应网络路径信息
  Content-Type: application/xml
  Content-Length: . . .
  
  <order xmlns=“http://starbucks.example.org/”>
      <drink>latte</drink>
      <cost>3.00</cost>
      <next xmlns=“http://example.org/state-machine”
          rel=“http://starbucks.example.org/payment”
          uri=“http://starbucks.example.com/payment/order/1234”
          type=“application/xml”/>//next用于描述前端之后要跳转到的路径信息
  </order>
  ```

- 在`REST`中，所有的`data`都被视作一种**`resource`**,并且这种`resource`应该是**有`data`与`presentation`共同决定的**。

- **`RestController`注解并不等价于`RESTFUL WebService`**.因为`controller`一般都是需要**多个不同的`API`**来表示不同的功能类型，并且一般**不会返回`HttpStatus`**,而一个`REST`需要返回`HttpStatus`并且需要通过`HttpHeader`来对于**同一个`API`**做出不同的了类型声明。

- `WS`的优点：

  - 可以跨平台
  - 可以穿防火墙，传输距离远
  - 是自描述的(`self-described`,对于`SOAP`,其需要对于其文本传输格式的声明文件`WSDL`,而`REST`由于是数据驱动的，所以只需要通过`HTTP Status/header`即可声明自己的需求)
  - 模块化

- `WS`的缺点：

  - 安全性不好需要依赖`HTTP+SSL`
  - 性能不好
  - 代码生产效率低下

- 面向服务的架构`SOA`:

  - 松耦合，即"解耦"，主要目的是使得某一个模块发生修改时不会影响其他模块或者对其他模块影响较小。在`SOA`,这种解耦主要体现在系统是通过将多个不同的功能模块集成到一起得到的，而不是全部由开发者自己实现得到的。这样的话，在某一个模块要更新的时候，只需要有那个服务对应的开发者进行更新就行了，而不影响总体的系统运行。
  - 位置透明，就是说用户(`service consumer`)只会调用这个服务而并不关心也不知道这个服务的位置属性
  - 协议独立

- 面向对象的设计三个主要层级：

  - `service`:是对于`component`的进一步包装，是面向具体的`application`得需求的。
  - `component`:主要是对`object`进行包装，从而解决一些具体的需求细节(`solution domain`)
  - `object`:细粒度，应该实现成可以复用的形式
  - `service`与`component`不一定是一对一的

- 