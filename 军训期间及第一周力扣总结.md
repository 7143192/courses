# 军训期间及开学第一周力扣刷题总结

- 首先是记录一下看到的一篇关于排序的很好地文章：https://leetcode.cn/circle/discuss/eBo9UB/。

## 文章时间范围内的算法目录：

- [二分查找](#erfen)
- [`DFS`](#DFS)
- [`BFS`](#BFS)
- [动态规划](#guihua)
- [双指针](#shuangzhizhen)
- [递归+回溯](#diguihuisu)

## <a id="erfen">二分查找</a>

- 二分查找基本逻辑是通过两个左右指针逐渐夹逼来寻找满足条件的结果。但是这个结果并不一定是一个单一的值，还可能是一个范围或遗一连串结果。

- 例子1：[力扣34](https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/comments/):找数字出现的左右边界，代码如下：

  ```cpp
  public:
      vector<int> searchRange(vector<int>& nums, int target) {
          //logn --> 二分查找
          vector<int> ans;
          for(int i = 0; i < 2; ++i) ans.push_back(-1);
          int left = 0;
          int right = nums.size() - 1;
          //循环终止时left>right,因而说明在上一次循环中left和right重合了，若重合点即为目标值，则将
          //right-1之后的新的left则是最大的右边界
          while(left <= right) {//while(left < right)
              int mid = (left + right) / 2;
              int tmp = nums[mid];
              if(tmp > target) right = mid - 1; //right = mid;
              else {
                  left = mid + 1;
                  ans[1] = mid;//从左向右逐渐逼近去找最大的右边界
              }
          }//找右边界
          left = 0;
          right = nums.size() - 1;
          while(left <= right) { //while(left < right)
              int mid = (left + right) / 2;
              int tmp = nums[mid];
              if(tmp < target) left = mid + 1;
              else {
                  right = mid - 1; //right = mid;
                  ans[0] = mid;//从右向左逐渐逼近，去找最小的左边界
              }
          }//找左边界
          if(ans[0] > ans[1]) {
              ans[0] = -1;
              ans[1] = -1;
          }
          if(ans[0] == -1 || ans[1] == -1) {
              ans[0] = -1;
              ans[1] = -1;
          }
          return ans;
      }
  ```

- 例子2：[力扣153](https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array/?plan=algorithms&plan_progress=zlevgss):寻找旋转数组的最小值。此题目逻辑比较简单，但是要注意旋转之后的新边界的处理。代码如下：

- ```cpp
  public:
      int findMin(vector<int>& nums) {
          //logn --> 二分法
          int left = 0;
          int right = nums.size() - 1;
          while(left < right) {
              int mid = (left + right) / 2;
              //nums[mid]>=nums[right]说明当前中间点位于未旋转的部分，而最小值显然位于已经旋转的
              //部分，所以下次搜索应该是向右搜索而不是向左
              if(nums[mid] >= nums[right]) left = mid + 1;
              //中间点已经位于旋转过的部分，则直接向左搜索
              else right = mid; 
          } 
          return nums[right];
      }
  ```

## <a id="DFS">`DFS`</a>

- `DFS`,即**广度优先遍历**，主要思想是**按照一个方向**不断的进行搜索，知道该路径出发了失败的条件或者成功地达到了终点。个人认为，由于`DFS`在一个起点上往往只能给出一组解，所以更适用于**存在性问题**，即，判断路径是否存在，返回任意一条路径等问题。其算法主要思路是**递归+回溯**。
- 一个`DFS`算法大致可以分为三个部分：**确定递归函数，确定终止条件，处理某个起点的所有出发路径并确定回溯方式**。即：

> 确定递归：
>
> vector<vector<int>> result; // 保存符合条件的所有路径
> vector<int> path; // 起点到终点的路径
> void `dfs` (图，目前搜索的节点)  
>
> 确定终止条件：
>
> ```cpp
> if (终止条件) {
>     存放结果;
>     return;
> }
> ```
>
> 处理所有出去的路径：
>
> ```cpp
> for (选择：本节点所连接的其他节点) {
>     处理节点;
>     dfs(图，选择的节点); // 递归
>     回溯，撤销处理结果
> }
> ```

- 例子1：[力扣797](https://leetcode.cn/problems/all-paths-from-source-to-target/):所有可能路径。`DFS`模板题。代码如下：

  ```cpp
  private:
      vector<vector<int>> path;
      vector<int> tmp;
      void DFS(vector<vector<int>>& graph, int start) {
          //tmp.push_back(start);
          if(start == graph.size() - 1) {
              path.push_back(tmp);
              return ;
          }//终止条件为当前起点已经是最后一个元素，说明一条路径已经生成。
          for(int i = 0; i < graph[start].size(); ++i) {
              tmp.push_back(graph[start][i]);
              DFS(graph, graph[start][i]);
              tmp.pop_back();//回溯，即退掉刚处理过的点，在递归的去处理与之相邻的同层节点
          }
      }
  public:
      vector<vector<int>> allPathsSourceTarget(vector<vector<int>>& graph) {
          int n = graph.size();
          if(n == 0) return path;
          //注意本题中的graph是一个**邻接矩阵**
          int num = graph[0].size();//获取起点的出边个数
          tmp.push_back(0);
          DFS(graph, 0);
          return path;
      }
  ```

- 例子2：[力扣130](https://leetcode.cn/problems/surrounded-regions/):被围绕的区域。代码如下：

  ```cpp
  private:
      void checkO(vector<vector<char>>& board, int i, int j) {
          if(i < 0 || j < 0 || i >= board.size() || j >= board[0].size() || board[i][j] != 'O') {
              return ;
          }
          board[i][j] = '1';
          checkO(board, i - 1, j);
          checkO(board, i, j + 1);
          checkO(board, i + 1, j);
          checkO(board, i, j - 1);
      }
  public:
      void solve(vector<vector<char>>& board) {
          int m = board.size();
          if(m == 0) return ;
          int n = board[0].size();
          if(n == 0) return ;
          //思路是深度优先遍历每一个位于边界'O',将其路径上面的O全部变为其他字符，因为这些O不可能是
          //满足要求的被包围的字符
          for(int i = 0; i < n; ++i) {
              checkO(board, 0, i);
              checkO(board, m - 1, i);
          }
          for(int i = 0; i < m;++i) {
              checkO(board, i, 0);
              checkO(board, i, n - 1);
          }
          for(int i = 0; i < m; ++i) {
              for(int j = 0; j < n; ++j) {
                  if(board[i][j] == 'O') board[i][j] = 'X';
                  if(board[i][j] == '1') board[i][j] = 'O';
              }
          }
      }
  ```

## <a id="BFS">`BFS`</a>

- `BFS`,即**广度优先遍历**，`BFS`在每一层的循环过程中，都是**遍历所有可能路径**，所以`BFS`可能更加适用于寻找**最值路径**的问题。

- 实例1：[力扣1091](https://leetcode.cn/problems/shortest-path-in-binary-matrix/):二进制矩阵的最短路径。代码如下：

  ```cpp
  public:
      int shortestPathBinaryMatrix(vector<vector<int>>& grid) {
          vector<pair<int, int>> direct = {{-1,-1},{-1,0},{-1,1},{0,-1},{0,1},{1,0},{1,-1},{1,1}};//矩阵中经常需要处理下一步的方向，形式应与此类似，比如SEP中的lab5
          int n = grid.size();
          if(n == 0) return -1;
          if(grid[0][0] == 1 || grid[n - 1][n - 1] == 1) return -1;
          if(n == 1) return 1;
          int ans = 1;//最开始已经经过了一个左上角的起始单元格
          vector<vector<int>> checked;
          for(int i = 0; i < n; ++i) {
              vector<int> line;
              for(int j = 0; j < n; ++j) {
                  line.push_back(0);
              }
              checked.push_back(line);
          }
          checked[0][0] = 1;
          queue<pair<int, int>> que;//回忆数据结构相关知识，BFS实际上类似于层次遍历，
          //所以一般需要使用一个queue。
          que.push({0, 0});
          //使用 **BFS** ,通过for循环遍历当前队列中每一个点找结果路径
          while(!que.empty()) {
              int size = que.size();
              for(int i = 0; i < size; ++i) {
                  int x0 = que.front().first;
                  int y0 = que.front().second;
                  //if(x0 == n - 1 && y0 == n - 1) return ans + 1;
                  que.pop();
                  for(int j = 0; j < 8; ++j) {
                      int dx = direct[j].first;
                      int dy = direct[j].second;
                      int x1 = x0 + dx;
                      int y1 = y0 + dy;
                      if(x1 < 0 || y1 < 0 || x1 >= n || y1 >= n) continue;
                      if(grid[x1][y1] == 1) continue;
                      if(checked[x1][y1] == 1) continue;
                      checked[x1][y1] = 1;
                      if(x1 == n - 1 && y1 == n - 1) return ans + 1;
                      que.push({x1, y1});
                  }
              }
              ans++;
          }
          return -1;
      }
  ```

## <a id="guihua">动态规划</a>

- 记录一篇详解动态规划的文章：[动态规划详解](https://leetcode.cn/problems/coin-change/solution/dong-tai-gui-hua-tao-lu-xiang-jie-by-wei-lai-bu-ke/)

## <a id="shuangzhizhen">双指针</a>

- 一般双指针有**同向运行的快慢指针，反向运行的夹逼双指针等**。同向快慢指针有包括指向同一个对象的指针和指向不同对象的指针两种情况。而反向夹逼双指针实际上典型应用就是**二分查找**。

- 实例1：[力扣15](https://leetcode.cn/problems/3sum/)：三数之和。代码如下：(指向同一个对象的快慢指针)

  ```cpp
  public:
      vector<vector<int>> threeSum(vector<int>& nums) {
          sort(nums.begin(), nums.end());//对数组进行排序，因为只要数值不需要索引
          vector<vector<int>> ans;
          for(int i = 0; i < nums.size() - 2; ++i) {
              if(nums[i] > 0) continue;//已经排好序了，说明后面都大于0，不可能和为0了
              int j = i + 1;
              int k = nums.size() - 1;
              while(j < k) {
                  int tmp = nums[i] + nums[j] + nums[k];
                  if(tmp == 0) {
                      vector<int> res;
                      res.push_back(nums[i]);
                      res.push_back(nums[j]);
                      res.push_back(nums[k]);
                      ans.push_back(res);
                      int tmp1 = nums[j];
                      int tmp2 = nums[k];
                      while(j < k && tmp1 == nums[j]) j++;
                      while(j < k && tmp2 == nums[k]) k--;//这步一定要有，同时缩进
                  }
                  else {
                      if(tmp < 0) {
                          j++;
                      }
                      else k--;
                  }
              }
              int tmp0 = nums[i];
              while(i < nums.size() - 2 && tmp0 == nums[i]) i++;
              i--;
          }
          return ans;
      }
  ```

- 实例2:[力扣844](https://leetcode.cn/problems/backspace-string-compare/?plan=algorithms&plan_progress=zlevgss):比较含有退格的字符串。代码如下：(指向不同对象的快慢指针，这种情况下会出现快慢一般是由于两个对象不同位置满足条件不同，而出现了进度不同步的现象)

  ```cpp
  public:
      bool backspaceCompare(string S, string T) {
          int sSkipNum = 0; // 记录S的#数量
          int tSkipNum = 0; // 记录T的#数量
          int i = S.size() - 1;
          int j = T.size() - 1;
          while (1) {
              while (i >= 0) { // 从后向前，消除S的#
                  if (S[i] == '#') sSkipNum++;
                  else {
                      if (sSkipNum > 0) sSkipNum--;
                      else break;
                  }
                  i--;
              }
              while (j >= 0) { // 从后向前，消除T的#
                  if (T[j] == '#') tSkipNum++;
                  else {
                      if (tSkipNum > 0) tSkipNum--;
                      else break;
                  }
                  j--;
              }
              // 后半部分#消除完了，接下来比较S[i] != T[j]
              if (i < 0 || j < 0) break; // S 或者T 遍历到头了
              if (S[i] != T[j]) return false;
              i--;j--;
          }
          // 说明S和T同时遍历完毕
          if (i == -1 && j == -1) return true;
          return false;
      }
  ```

- 实例3：[力扣61](https://leetcode.cn/problems/container-with-most-water/?plan=algorithms&plan_progress=zlevgss):称最多水的容器。代码如下：(反向双指针)

  ```cpp
  public:
      int maxArea(vector<int>& height) {
          int left = 0;
          int right = height.size() - 1;
          int ans = 0;
          while(left < right) {
              int h = (height[left] <= height[right]) ? height[left] : height[right];
              int tmp = h * (right - left);
              ans = (ans >= tmp) ? ans : tmp;
              //这里只能向右走,是因为此时left高度低，因而是确定最终高度的可能位置(木桶效应)，而如果向
              //左走，只可能高度继续下降而不会升高，并且宽度也会下降，容积一定会下降，只有向右走才有可			 //能变大
              if(height[left] <= height[right]) left++;
              else right--;
          }
          return ans;
      }
  ```

## <a id = "diguihuisu">递归+回溯</a>

- 回溯一般都是和递归配套使用的。其主要是用于需要“回头”来找出所有的解的问题中。即满足结束条件或者发现不是正确路径的时候(走不通)，要撤销选择，回退到上一个状态，继续尝试，直到找出所有解为止。

- [回溯算法的要点](https://leetcode.cn/problems/subsets/solution/c-zong-jie-liao-hui-su-wen-ti-lei-xing-dai-ni-gao-/)：

  ①画出递归树，找到状态变量(回溯函数的参数)，这一步非常重要※
  ②根据题意，确立结束条件
  ③找准选择列表(与函数参数相关),与第一步紧密关联※
  ④判断是否需要剪枝
  ⑤作出选择，递归调用，进入下一层
  ⑥撤销选择

- 实例1：[力扣78](https://leetcode.cn/problems/subsets/):子集。代码如下：

  ```cpp
  private:
      void getSets(vector<vector<int>>& ans, vector<int>& tmp,vector<int>& nums, int i) 
  {
      ans.push_back(tmp);//因为要找子集，所以每次开始递归时都要把当前集合放入结果，
          //其实这也是一种边界情况，比如第一次进入时就会将[]放入结果集合。
      if(i >= nums.size()) {//终止条件为结果长度已经超过数组长度，说明当前情况下所有子集已经获取
          //return是要回溯回去去尝试其他组合
          return ;
      }
      for(int j = i; j < nums.size(); ++j) {
          tmp.push_back(nums[j]);
          getSets(ans, tmp, nums, j + 1);
          tmp.pop_back();
      }
  }
  public:
      vector<vector<int>> subsets(vector<int>& nums) {
          vector<vector<int>> ans;
          vector<int> tmp;
          getSets(ans, tmp, nums, 0);
          return ans;
      }
  ```

- 实例2：[力扣90](https://leetcode.cn/problems/subsets-ii/submissions/):子集II。代码如下。参考题解：https://leetcode.cn/problems/subsets-ii/solution/90-zi-ji-iiche-di-li-jie-zi-ji-wen-ti-ru-djmf/。

  ```cpp
  private:
      vector<vector<int>> result;
      vector<int> path;
      void backtracking(vector<int>& nums, int startIndex, vector<bool>& used) {
          result.push_back(path);
          for (int i = startIndex; i < nums.size(); i++) {
              // used[i - 1] == true，说明同一树支candidates[i - 1]使用过
              // used[i - 1] == false，说明同一树层candidates[i - 1]使用过
              // 而我们要对同一树层使用过的元素进行跳过
              if (i > 0 && nums[i] == nums[i - 1] && used[i - 1] == false) {
                  continue;
              }
              path.push_back(nums[i]);
              used[i] = true;
              backtracking(nums, i + 1, used);
              used[i] = false;
              path.pop_back();
          }
      }
  
  public:
      vector<vector<int>> subsetsWithDup(vector<int>& nums) {
          result.clear();
          path.clear();
          vector<bool> used(nums.size(), false);
          sort(nums.begin(), nums.end()); // 去重需要排序
          backtracking(nums, 0, used);
          return result;
      }
  ```

- 实例3：[力扣47](https://leetcode.cn/problems/permutations-ii/?plan=algorithms&plan_progress=zlevgss)：全排列II。代码如下。

  ```cpp
  private:
      vector<vector<int>> ans;
      void Perm(vector<int> nums, int start) {
          //注意与子集问题的区别！
          if(start == nums.size() - 1) {
              ans.push_back(nums);
              return ;
          }
          for(int i = start; i < nums.size(); ++i) {
              if(i != start && nums[start] == nums[i]) continue;
              //直接修改原数组
              int t1 = nums[start];
              nums[start] = nums[i];
              nums[i] = t1;
              Perm(nums, start + 1);
          }
      }
  public:
      vector<vector<int>> permuteUnique(vector<int>& nums) {
          if(nums.size() == 0) return ans;
          sort(nums.begin(), nums.end());
          Perm(nums, 0);
          return ans;
      }
  ```
