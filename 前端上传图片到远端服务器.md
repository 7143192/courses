# 前端通过后端向远端服务器上传图片

- 本次上传使用的前端是通过`react-native`编写的，后端使用的是`springBoot`框架。主要目的是完成大二暑期项目的发布动态时将相关图片存储在网络服务器上面，并将生成的服务器路径存储在数据库中。

- **第一部分**内容为**文件服务器**相关配置。在本次操作中，使用**远端服务器**的**`tomcat`**作为文件服务器。具体配置如下：

- 首先修改`server.xml`文件。在`<Host>`标签下面添加如下内容1。其中`docBase`表示的是用于存储上传文件的文件夹名称。**若使用的是`webapps`下的文件夹，则`docBase`下的内容不能加上`/`字符！**而`Host`标签下面默认是包含了`appBase="webapps"`的，所以不需要添加`/`。`path`则指的是访问路径，设置之后则可以通过**`http://IP:port/uploadfiles/`**的网络路径来访问上传到服务器中的文件。另外，最好修改`server.xml`中`<connector>`标签下面的`port`参数的值，改为另外一个**远端服务器已经开放的端口**，(本次项目使用的是华为云，通过修改安全组来开放想要的端口)因为`tomcat`默认链接路径为8080端口，但是8080端口运行的项目可能涉及到**鉴权**问题，所以直接访问会访问不到，对于后续的效果查看以及前端文件数据下载都不友好。

  ```XML
  内容1：<Context docBase="uploadfiles" path="/uploadfiles" debug="0" reloadable="true"/>
  ```

- 之后在`tomcat`的运行目录下面的`webapps`文件架下面新建一个名为`uploadfiles`的目录，用于存储上传的文件，名称应该与上一步配置的`path`相同。`tips:`如果忘了`tomcat`的安装路径，可以在根目录下运行**`find / -name tomcat`**来查找!

- 之后修改`web.xml`配置文件。在对应位置添加/修改为一下内容即可：

  ```xml
  <servlet>
      <servlet-name>default</servlet-name>
      <servlet-class>org.apache.catalina.servlets.DefaultServlet</servlet-class>
      <init-param>
          <param-name>debug</param-name>
          <param-value>0</param-value>
      </init-param>
      <init-param>
          <param-name>listings</param-name>
          <param-value>true</param-value>
      </init-param>
      <init-param>
          <param-name>readonly</param-name>
          <param-value>false</param-value>
      </init-param>//很关键，如果设置为true，则远端服务器不能将上传的文件写到这个文件夹内部
      <load-on-startup>1</load-on-startup>
  </servlet>
  ```

- 最后重新启动`tomcat`服务即可。在`Linux`系统下，在`tomcat安装路径/bin`目录下面运行`./shutdown.sh`和`./startup.sh`即可。`tips:``JDK10`之后的版本的`tar.gz`包里面**已经不包含`jre`目录了**，所以如果远端服务器在使用10及以上版本的`JDK`时，配置的`JRE_HOME`应该改为**`export JRE_HOME=$JAVA_HOME`**。

- **第二部分**为`SpringBoot`后端相关的配置。本次上传的核心逻辑是，**将前端上传过来的`Base64`格式的数据转化为`MultiPartFile`类型的数据之后通过`Jersey`上传到远端服务器上面**。首先在`pom.xml`中添加入下配置并更新：

  ```xml
  #用于上传文件的Jersey相关依赖
  <dependency>
      <groupId>com.sun.jersey</groupId>
      <artifactId>jersey-core</artifactId>
      <version>1.19.4</version>
  </dependency>
  <dependency>
      <groupId>com.sun.jersey</groupId>
      <artifactId>jersey-client</artifactId>
      <version>1.19.4</version>
  </dependency>
  
  <dependency>
      <groupId>commons-fileupload</groupId>
      <artifactId>commons-fileupload</artifactId>
      <version>1.2.2</version>
  </dependency>
  
  <dependency>
      <groupId>org.apache.tomcat.embed</groupId>
      <artifactId>tomcat-embed-jasper</artifactId>
      <scope>provided</scope>
  </dependency>
  #用于访问上传之后文件的静态资源的相关依赖
  <dependency>
      <groupId>org.springframework</groupId>
      <artifactId>spring-webmvc</artifactId>
  </dependency>
  ```

- 之后需要先实现`Base64`类型向`MultiPartFile`类型进行转换的函数,之后再实现向远端服务器的上传。相关代码如下：

  ```java
  //首先是相关实现类的构造函数
  public class BASE64DecodedMultipartFile implements MultipartFile {
      private final byte[] fileContent;
      private final String extension;
      private final String contentType;
      /**
       * @param base64
       * @param dataUri     格式类似于: data:image/png;base64
       */
      public BASE64DecodedMultipartFile(String base64, String dataUri) {
          this.fileContent = Base64.getDecoder().decode(base64.getBytes(StandardCharsets.UTF_8));
          this.extension = dataUri.split(";")[0].split("/")[1];
          this.contentType = dataUri.split(";")[0].split(":")[1];
      }
  
      public BASE64DecodedMultipartFile(String base64, String extension, String contentType) {
          this.fileContent = Base64.getDecoder().decode(base64.getBytes(StandardCharsets.UTF_8));
          this.extension = extension;
          this.contentType = contentType;
      }
  	。。。。
  }
  
  //之后是转换函数
  @RequestMapping(value = "/addMomentAndImages", consumes = {"multipart/form-data"})
      public @ResponseBody
      Moment addMomentAndImages(@RequestParam("userId") int user_id,
                                @RequestParam("content") String content,
                                String base64)
          //此处的base64存储的是前端传递过来的包含每个图片base64以及name的JSON字符串。
      {
          System.out.println("string base64=" + base64);
          JSONArray json = JSONArray.fromObject(base64);//首先是解析字符串
          List<MultipartFile> images = new ArrayList<>();
          for (int i= 0; i < json.size(); i++) {//遍历，转换每一张图片
              JSONObject jsonOne = json.getJSONObject(i);
              String got_base64 = jsonOne.getString("base64");
              final String[] base64Array = got_base64.split(",");
              String dataUir, data;
              if (base64Array.length > 1) {
                  dataUir = base64Array[0];
                  data = base64Array[1];
              } else {
                  //根据你base64代表的具体文件构建
                  dataUir = "data:image/jpg;base64";
                  data = base64Array[0];
              }//这个else是在处理有的base64不包含headers的情况(比如说我的QAQ。。。)
              MultipartFile multipartFile = new BASE64DecodedMultipartFile(data, dataUir);//根据解析信息进行MultiPartFile的创建。
              images.add(multipartFile);
          }
          return momentService.addMomentAndImages(user_id, content, images);
      }
  //最后一部分即为上传函数，如下：
    @Override
      public Moment addMomentAndImages(int user_id, String content, List<MultipartFile> images)
      {
          Moment moment = addMoment(user_id, content);//首先插入动态对应的文字部分
          List<Moment> moments = momentRepository.getAllMoments();
          //获取图片关联的外键的数值
          int momentId = moments.get(moments.size() - 1).getMoment_id();
          //这里的path要和第一部分的tomcat配置相对应
          String path = "http://124.71.177.146:80/uploadfiles";
          for(int i = 0; i < images.size(); ++i) {
              MultipartFile file = images.get(i);
              String s = file.getOriginalFilename();
              System.out.println("original name=" + s);
              //为上传到服务器的文件取名，使用UUID防止文件名重复
              String type = s.substring(s.lastIndexOf("."));
              String filename= UUID.randomUUID().toString() + type;//生成新的随机文件名
              try{
                  //使用Jersey客户端上传文件
                  Client client = Client.create();
                  WebResource webResource = client.resource(path +"/" + URLEncoder.encode(filename,"utf-8"));
                  webResource.put(file.getBytes());//通过Jersey将相关数据写到对应位置
                  System.out.println("上传成功");
                  MomentImage image = new MomentImage();
                  image.setMoment_id(momentId);
                  image.setImg(path + "/" + filename);
                  momentImageRepository.save(image);
                  momentImageRepository.flush();
                  //之后保存一个以及上传到服务器的图片信息到数据库中
              }catch(Exception ex){
                  System.out.println("exception ex=" + ex);
                  System.out.println("上传失败");
              }
          }
          return moment;
      }  
  ```

- 在`application.properties`中添加如下内容：

  ```properties
  #MultiPartFile相关配置
  spring.servlet.multipart.enabled=true
  spring.servlet.multipart.max-file-size=20MB
  spring.servlet.multipart.max-request-size=200MB
  #tomcat的http请求最大传输量限制
  server.tomcat.max-http-form-post-size=-1
  #远端服务器静态资源访问配置
  spring.mvc.static-path-pattern=/uploadfiles/**
  spring.web.resources.static-locations=file:/www/server/tomcat/webapps/uploadfiles/
  ```

- **最后一部分**是处理前端如何向后端发送base64格式数据以及其他相关信息。这里采用的是`FormData`进行发送。

- 前端将图片数据转化为`base64`格式的函数为：

  ```react
  RNFS.readFile(item.uri, 'base64')//item.uri传递的是要读取的文件的本地路径
    .then(content => {
      // content 为base64数据
      item.base64 = content;
      tmpImgList.push(item);
      this.setState({tmpImgList});
    })
    .catch(err => {
      console.log('reading error: ' + err);
    });
  ```

- 前端向后端发送`FormData`数据的格式如下。

  ```react
  ....
  formBody.append("base64", JSON.stringfy(tmpArr));//第一个参数为字段名称，第二个参数是这个字段存储的数据。
  ....
  fetch(url, {
    method: 'post',
    headers: {
      token: SyncStorage.getValue('token'),
      'content-Type': 'multipart/form-data',//必要的content-Type声明
    },
    //body: fetchBody,
    body: formBody,
  })
    .then(response => response.json())
    .then(data => {
      。。。。
    });
  ```

- 后端在读取`FormData`数据时，使用的方式与读取一般的`JSON`不完全一样。具体可以参考如下博客：https://blog.csdn.net/qq_52889967/article/details/122810232。